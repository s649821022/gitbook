# migrate怎么判断哪些迁移脚本需要执行：
他会将代码中的迁移脚本和数据库中`django_migrations`中的迁移脚本进行对比，如果发现数据库中，没有这个迁移脚本，那么就会执行这个迁移脚本。

# migrate做了什么事情：
1. 将相关的迁移脚本翻译成SQL语句，在数据库中执行这个SQL语句。
2. 如果这个SQL语句执行没有问题，那么就会将这个迁移脚本的名字记录到`django_migrations`中。


# 执行migrate命令的时候报错的解决办法：

## 原因：
执行migrate命令会报错的原因是。数据库的`django_migrations`表中的迁移版本记录和代码中的迁移脚本不一致导致的。

## 解决办法：

### 使用--fake参数：
首先对比数据库中的迁移脚本和代码中的迁移脚本。然后找到哪个不同，之后再使用`--fake`，将代码中的迁移脚本添加到`django_migrations`中，但是并不会执行sql语句。这样就可以避免每次执行`migrate`的时候，都执行一些重复的迁移脚本。

### 终极解决方案：
如果代码中的迁移脚本和数据库中的迁移脚本实在太多，就是搞不清了。那么这时候就可以使用以下终极解决方案：
1. 终极解决方案原理：就是将之前的那些迁移脚本都不用了。重新来过。要将出问题的app下的所有模型和数据库中表保持一致，重新映射。
2. 将出问题的app下的所有模型，都和数据库中的表保持一致。
3. 将出问题的app下的所有迁移脚本文件都删掉。再在`django_migrations`表中将出问题的app相关的迁移记录都删掉。
4. 使用`makemigrations`，重新将模型生成一个迁移脚本。
5. 使用`migrate --fake-initial`参数，将刚刚生成的迁移脚本，标记为已经完成（因为这些模型相对应的表，其实都已经在数据库中存在了，不需要重复执行了。）
6. 可以做其他的映射了。